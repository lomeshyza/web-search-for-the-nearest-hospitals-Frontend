### Common

- по возможности делите импорты по слоям. Это не всегда имеет смысл, но улучшает структуру вашего кода:
  import './style'

  import '~/shared/...'
  import '~/shared/...'
  import '~/shared/...'

  import '~/widgets/...'
  import '~/widgets/...'

- если в дизайне есть ui-kit, то он должен быть в shared/ui и storybook. Но выбирая между feature и storybook, не тратьте время на последнее.
- оставляйте "@TODO:" комментарии и ищите их для фиксов
- старайтесь не оставлять закомментированный код без необходимости, или же старайтесь пояснять, в чём его ценность
- если не знаете, как подключить свой код, не сломав чужой - попросите совета.
- для коммитов используйте команду 'npm run commit'

### Types

- ts уже документирует за вас входные и выходные параметры функций, вам остаётся лишь назвать её так, чтобы стало понятно её назначение. Может быть полезно прокомментировать нюансы работы.
- типизируйте переменные окружения внутри vite-env.d.ts.
- Component: FC<SomeType> = ({....}) - несколько устаревший подход. Component = ({....}: SomeType) - будет достаточно и короче.

### Styles

- импорт стилей должен идти первым в файле.
- по возможности старайтесь использовать style.module.scss вместо style.scss. Первые будут работать только внутри файла, вторые попадают в общий список стилей и могут задеть чужие компоненты (например, вы назвали card и ваш коллега в своём компоненте имеет некий card, подключенные глобально стили будут перебивать друг друга). Тем не менее, помните, что модули имеют "блочную видимость". Т.е. нужно четко разделять глобальные стили, которые должны влиять на весь код и локальные стили, которые мы заключаем в модуль. Также следует помнить, что для уникализации, к module-стилям добавляется хеш, который и делает стиль "уникальным" (см классы через devTools).
- не забывайте о БЭМ. Позиционирование дочерних элементов задаётся на уровне родителя через блоки-обёртки. Это нормально, если мы придерживаемся методологии.
- если вы создаёте специальные стили для storybook, их нейминг тоже должен быть в рамках принятой идеологии - БЭМ.
- короткие стили для разметки можно писать по типу css-in-js. Главное, чтобы это не превращалось в полотно. Разметка должна быть разметкой, а стили - стилями. Этим лучше не злоупотреблять.

### Configs

- названия переменных окружения должны начинаться с VITE\_ и доступны через `import.meta.env.<your-key>`.
- в eslint конфиге есть 2 настройки, которые позволяют вам не удалять неиспользуемые переменные на этапе рефакторинга, а также допускают использование 'any' для типизации. Это удобно для экспериментов и позволяет более гибко работать с кодом. Тем не менее, на этапе сборки эти ошибки отклонят процесс и вам всё равно нужно будет это поправить.

### Maps

- https://pbe-react-yandex-maps.vercel.app/ - документация сторонней библиотеки для работы с Я.Картами на React.
- https://developer.tech.yandex.ru - ссылка на личный кабинет разработчика для Яндекс карт API. Здесь можно получить ключ для карт.

### About

- Как работает 'npm run commit'? Запускает ряд команд. lint-staged проверяет только измененные файлы. Т.е. если ошибка появилась где-то в уже рабочих файлах, он её не отловит. Но для отслеживания таких ошибок у вас есть вклада 'problems\проблемы' в среде разработки(VSC), а также скрипт, который запустится перед lint-staged: 'npm run build' - он проверит возможность собрать проект в принципе и на этом этапе отловит большую часть критических ошибок.
- https://questu.ru/articles/78940/ - русскоязычная статья по работе husky & lint-staged.

### Error handler & notifications

- https://fkhadra.github.io/react-toastify/introduction/ - на основе этой библиотеки мы уведомляем пользователя о разных штуках.
- для создания тостов используйте фабрику 'createToast'
- при необходимости по аналогии расширьте фабрику под ваши нужды
